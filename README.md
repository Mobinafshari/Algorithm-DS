# Data Structures and Algorithms Practice

This repository is a personal collection of implemented data structures and algorithms for learning and practice purposes and I will implement them several times.

## Implemented Data Structures and Algorithms

### Basic Data Structures

#### [Binary-search-tree](./Binary-search-tree/)
A Binary Search Tree (BST) is a hierarchical data structure where each node has at most two children: the left child contains smaller values, and the right child contains larger values. This enables efficient searching, insertion, and deletion, typically in O(log n) time for balanced trees.


![Screenshot (130)](https://github.com/user-attachments/assets/df31ba6e-597c-4ddf-bc7b-73bab49e5fc2)

#### [Doubly-Linked-list](./Doubly-Linked-list/)
Implementation of Doubly Linked List

#### [Linked-list](./Linked-list/)
<p align="center">
  <img src="https://github.com/user-attachments/assets/6edf4325-a034-4aa6-9cc1-e8227c553609" alt="Linked-list">
</p>

<p align="center">A linked list is a linear data structure where elements (nodes) are linked together using pointers. Unlike arrays, linked lists do not store elements in contiguous memory locations.</p>

#### [Stack-ds](./Stack-ds/)
<p align="center">
  <img src="https://github.com/user-attachments/assets/ef7e996b-629e-4dc5-9d17-5efb1266eaeb" alt="stack">
</p>

<p align="center">
A stack is a linear data structure that follows the Last In, First Out (LIFO) principle, meaning the last element added is the first to be removed.
</p>

### Sorting Algorithms

#### [Bubble-sort](./Bubble-sort/)
Implementation of Bubble Sort

#### [Insertion-sort](./Insertion-sort/)
Implementation of Insertion Sort

#### [Merge-sort](./Merge-sort/)
Implementation of Merge Sort

### Searching Algorithms

#### [Binary-search](./Binary-search/)
Implementation of Binary Search

### Graph Algorithms

#### [BFS](./BFS/)
Implementation of BFS (Breadth-First Search)

#### [Bellman-Ford](./Bellman-Ford/)
Implementation of Bellman-Ford Algorithm

#### [DFS](./DFS/)
Implementation of DFS (Depth-First Search)

#### [Dijkstra](./Dijkstra/)
Implementation of Dijkstra's Algorithm

#### [Kruskal](./Kruskal/)
Implementation of Kruskal's Algorithm

#### [Network-Flow](./Network-Flow/)
Implementation of Network Flow (e.g., Edmonds-Karp Algorithm)

#### [Prim](./Prim/)
Implementation of Prim's Algorithm

#### [Topological-sort](./Topological-sort/)
Implementation of Topological Sort

## How to Use

This repository is primarily for learning and reference. You can explore the implementation details by looking into the `index.js` file located within each algorithm or data structure's directory.

To run or test these implementations, you will generally need a JavaScript environment. This could be:
- **Node.js:** You can execute the `.js` files directly in your terminal (e.g., ``node BFS/index.js``).
- **Browser Console:** You can copy and paste the code into your web browser's developer console.

Please note that some implementations might have specific examples or dependencies mentioned within their respective directories or code comments.

## Areas for Practice

This repository is a work in progress, and there are many ways you can use it to practice your skills:

- **Implement New Algorithms/Data Structures:** Choose an algorithm or data structure not yet in the repository and try to implement it.
- **Add Test Cases:** For existing implementations, add more comprehensive test cases or usage examples to ensure correctness and demonstrate functionality.
- **Improve Explanations:** Enhance the descriptions in `description.md` files or add more detailed comments within the code.
- **Optimize Existing Code:** Look for ways to improve the efficiency or readability of the current implementations.
- **Explore Variations:** Implement alternative versions of existing algorithms or data structures (e.g., different types of a Tree, or another sorting algorithm).

---
Happy Learning and Coding!
